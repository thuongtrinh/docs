http://viettuts.vn/java-collection/su-khac-nhau-giua-array-voi-arraylist
Map và Collection là hoàn toàn tách biệt
1. Khác nhau của HashMap, LinkedHashMap và TreeMap
╔══════════════╦═════════════════════╦═══════════════════╦══════════════════════╗
║   Property   ║       HashMap       ║      TreeMap      ║     LinkedHashMap    ║
╠══════════════╬═════════════════════╬═══════════════════╬══════════════════════╣
║              ║  no guarantee order ║ sorted according  ║                      ║
║   Order      ║ will remain constant║ to the natural    ║    insertion-order   ║
║              ║      over time      ║    ordering       ║                      ║
╠══════════════╬═════════════════════╬═══════════════════╬══════════════════════╣
║  Get/put     ║                     ║                   ║                      ║
║   remove     ║         O(1)        ║      O(log(n))    ║         O(1)         ║
║ containsKey  ║                     ║                   ║                      ║
╠══════════════╬═════════════════════╬═══════════════════╬══════════════════════╣
║              ║                     ║   NavigableMap    ║                      ║
║  Interfaces  ║         Map         ║       Map         ║         Map          ║
║              ║                     ║    SortedMap      ║                      ║
╠══════════════╬═════════════════════╬═══════════════════╬══════════════════════╣
║              ║                     ║                   ║                      ║
║     Null     ║       allowed       ║    only values    ║       allowed        ║
║ values/keys  ║                     ║                   ║                      ║
╠══════════════╬═════════════════════╩═══════════════════╩══════════════════════╣
║              ║   Fail-fast behavior of an iterator cannot be guaranteed       ║
║   Fail-fast  ║ impossible to make any hard guarantees in the presence of      ║
║   behavior   ║           unsynchronized concurrent modification               ║
╠══════════════╬═════════════════════╦═══════════════════╦══════════════════════╣
║              ║                     ║                   ║                      ║
║Implementation║      buckets        ║   Red-Black Tree  ║    double-linked     ║
║              ║                     ║                   ║       buckets        ║
╠══════════════╬═════════════════════╩═══════════════════╩══════════════════════╣
║      Is      ║                                                                ║
║ synchronized ║              implementation is not synchronized                ║
╚══════════════╩════════════════════════════════════════════════════════════════╝


Factory method => Design pattern

2. Khác nhau của HashSet, LinkedHashSet và TreeSet

- HashSet cho phép tối đa một phần tử null.	
- LinkedHashSet  cũng cho phép tối đa một phần tử null.	
- TreeSet không cho phép chứa phần tử null. Nếu bạn cố gắng để chèn null thành phần TreeSet, nó ném NullPointerException.

- HashSet cho hiệu suất tốt hơn so với LinkedHashSet và TreeSet.	
- Hiệu suất của LinkedHashSet nằm giữa HashSet và TreeSet. Hiệu suất của nó hầu như tương tự như HashSet. Nhưng hơi chậm hơn vì nó cũng duy trì LinkedList nội bộ để duy trì trình tự chèn các phần tử.	
- TreeSet cho hiệu suất thấp hơn HashSet và LinkedHashSet vì nó phải sắp xếp các phần tử sau mỗi lần chèn và loại bỏ.

- HashSet không duy trì bất kỳ thứ tự các phần tử được thêm vào.	
- LinkedHashSet duy trì thứ tự chèn của các phần tử. Các phần tử được lưu trữ đúng như thứ tự chúng được chèn vào.
- TreeSet duy trì thứ tự các phần tử theo bộ so sánh được cung cấp (Comparator). Nếu không có bộ so sánh được cung cấp, các phần tử sẽ được đặt theo thứ tự tăng dần tự nhiên của chúng.

- HashSet sử dụng các phương thức equals() và hashCode() để so sánh các phần tử và do đó loại bỏ các phần tử có thể trùng lặp.	
- LinkedHashSet cũng sử dụng phương thức equals() và hashCode() để so sánh các phần tử.	
- TreeSet sử dụng phương pháp compare() hoặc compareTo() để so sánh các phần tử và do đó loại bỏ các phần tử có thể trùng lặp. Nó không sử dụng các phương thức equals () và hashCode () để so sánh các phần tử.

- Sử dụng HashSet nếu bạn muốn danh sách không chứa phần tử trùng và không cần duy trì bất kỳ thứ tự các phần tử được chèn vào.
- Sử dụng LinkedHashSet nếu bạn muốn danh sách không chứa phần tử trùng và muốn duy trì thứ tự chèn của các phần tử.
- Sử dụng TreeSet nếu bạn muốn danh sách không chứa phần tử trùng và muốn sắp xếp các phần tử theo một số so sánh.


3. Nhưng có nhiều sự khác nhau giữa HashMap và Hashtable được đưa ra dưới đây.

HashMap								Hashtable
1) HashMap cho phép một key là null và nhiều giá trị null.	Hashtable không cho phép bất kỳ key hoặc giá trị null.
2) HashMap không đồng bộ.					Hashtable là đồng bộ.
3) HashMap là một lớp mới được giới thiệu trong JDK 1.2.	Hashtable là một lớp legacy.
4) HashMap nhanh.						Hashtable chậm.
5) Chúng ta có thể làm cho HashMap đồng bộ bằng cách  		Hashtable được đồng bộ nội bộ và không thể hủy 
gọi phương thức:						đồng bộ hóa.
Map m = Collections.synchronizedMap(hashMap);			
6) HashMap được duyệt bởi Iterator.				Hashtable được duyệt bởi Enumerator và Iterator.
7) Iterator trong HashMap là fail-fast.				Enumerator trong Hashtable là không fail-fast.
8) HashMap kế thừa lớp AbstractMap.				Hashtable kế thừa lớp Dictionary.


Note 1: A constructor must have the same name as the class, hence a is not a constructor. It must not return any value, hence c is not correct. A constructor cannot be declared abstract or final. 

Note 2: Java does not allow casts between boolean values and any numeric types. Hence a is incorrect. Assigning double to a float requires an explicit cast. Hence b and e are incorrect.

Note 3: final modifier may appear before a method, a variable or before a class. 

------------------------------------------------------------------------------

synchronization.This is the reason that HashMap should be used if the program is thread-safe.

*HashMap
 No Duplicate Key are allowed, But values can be anything.
 Orders cannot be predicted, in can print the data in any order
 Supports 1 null Key
 Gives good performance on read and write
*) TreeMap
 No Duplicate Key are allowed, But values can be anything.
 TreeMap will follow the natural ordering of key, All Keys in the TreeMap should be in same type
 Does not support null key elements
 Slow when compared with HashMap, use this only when you need ordering by default
*)LinkedHashMap
 No Duplicate Key are allowed, But values can be anything.
 LinkedHashMap insertion order will be maintained, Adding duplicate key will not affect the    existing order.
 Supports 1 null elements
 Slow when compared with HashMap, but faster than TreeMap, Use this if you need to maintain the   insertion order of the data.



